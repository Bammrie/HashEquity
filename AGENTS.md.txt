Canonical spec for HashEquity.com. This file defines scope, data models, services, contracts, APIs, and workflow rules. If code diverges from this spec, the code is wrong.

0) Project Summary

HashEquity is a click-based crypto game and NFT ecosystem on Polygon (MATIC). Players earn HASH exclusively through gameplay. No presale, no admin allotments. All tokens are minted via play and daily settlement.
Core pillars:
Simple loop, deep meta: 10 clickable objects that float around a game area on screen; destroy → reward → respawn.
Economy controls: 20% daily mint tax to the HashVault; optional 50% trade-in from Unminted → real HASH.

Retention: NFTs require ongoing HASH burns to unlock rewards. Failure destroys the NFT; rewards revert to Vault.
Modularity: object types and mini-games are plug-in modules; NFTs level/merge over time.
Admin clarity: live telemetry for Vault, users, NFTs, object events.

1) Repos & Ownership Map
Authoritative sources as of this document:
Backend API & Services

Responsibilities: REST + Socket.IO, Prisma/Postgres, cron jobs (00:00 UTC mint run, NFT validation), Vault trade service, withdrawals, auth/session.
Frontend Web App

Responsibilities: Game UI (10-object loop), wallet connect, balances, NFT dashboard (burn/merge), admin UI, charts.

Contracts / Deployment
Repo: hashtoken-deploy

URL: https://github.com/Bammrie/hashtoken-deploy
Responsibilities: HASH ERC-20 (already deployed), new NFT contracts (ERC-721 or 1155), scripting for mints/transfers, env wiring for Polygon RPC.

Optional improvement: convert to a mono-repo (/apps/frontend, /apps/backend, /packages/contracts) once you’ve stabilized. Not required to move forward.

2) Environments

Runtime stack

Frontend: React + Vite (or Next.js if you prefer SSR later), Zustand/Redux, wagmi + rainbowkit, Recharts.

Backend: Node.js + Express, Mongoose + MongoDB, Socket.IO, node-cron, ethers.js.

Chain: Polygon (MATIC), public RPC (Alchemy/Infura/Ankr/etc.).

Railway

Backend service (Node)

MongoDB

Frontend hosting (if used) or point to S3/CloudFront later

Environment variables (backend)

MONGO_URI=mongodb+srv://...
CHAIN_ID=137
RPC_URL=<polygon-rpc>
VAULT_PRIVATE_KEY=<hot-wallet key>    # protect
VAULT_ADDRESS=0x...
HASH_TOKEN_ADDRESS=0x...
NFT_CONTRACT_ADDRESS=0x...            # set when deployed
MINT_CRON_SCHEDULE=0 0 * * *          # 00:00 UTC
JWT_SECRET=<if you use JWT>
SOCKET_CORS_ORIGIN=https://www.HashEquity.com


Environment variables (frontend)

VITE_CHAIN_ID=137
VITE_RPC_URL=<polygon-rpc>
VITE_HASH_TOKEN_ADDRESS=0x...
VITE_NFT_CONTRACT_ADDRESS=0x...
VITE_BACKEND_URL=https://api.hashequity.com


Secrets live in Railway/hosted secret managers. Never commit them.
3) Core Entities

Player

Wallet-linked account; two balances: hash_balance and unminted_hash_balance.

Object

Spawned items on the game field; each has type, spawn_chance, destroy reward(if clicked on enough times), time before dissapearance(# of seconds on screen before dissapering without destroy reward.

Some objects pay unminted directly; others trigger mini-games (defined in the destroy reward), others mint NFTs.

HashVault(Admin Login)

Single hot wallet. Receives 20% of daily mint. Pays 50% trade-in conversions. Holds both real and unminted balances in DB.

NFT

On-chain token with burn requirements and a pending reward. States: active, destroyed, completed, mergeable.

4) Data Model (MongoDB)

Persistence lives in MongoDB with Mongoose models. Key collections:

User
- `walletAddress` (string, lowercase, unique) — primary key for logins.
- `hashBalance` (number) — minted HASH already settled to the account.
- `unmintedHash` (number) — pending rewards awaiting the daily mint.
- Automatic timestamps track creation/update moments.

Stats
- `objectId` (string, unique) — identifier the frontend sends when destroying an object.
- `name` (string, optional) — friendly label to display; fallback to a humanized objectId.
- `image` (string, optional) — URL for the collectible art.
- `destroyed` (number) — total destroy count for leaderboard ordering.
- Automatic timestamps.

Add secondary collections (ObjectEvent, Vault, NFT, etc.) as the corresponding features come online. Use compound indexes for frequent lookups (e.g., `{ walletAddress: 1 }`, `{ objectId: 1 }`, `{ userId: 1, timestamp: -1 }`).

Migration notes

No Prisma migrations. When altering schemas, write idempotent Mongoose migration scripts and back up production data before running them.

5) Game Mechanics
Object spawn rules

Exactly 10 objects visible at all times.

When one is destroyed, immediately spawn a new one using weighted random selection (weights sum to 1.0).

Spawn table lives server-side. Frontend only renders what it’s told.

Destroy event

Client sends POST /game/objects/:id/destroy.

Backend validates that id was actually present and not double-clicked.

Backend records ObjectEvent, increments user unminted_hash_balance or triggers mini-game logic, emits live updates via Socket.IO.

Return new object to place client-side.

Mini-games

Mini-games are module handlers. Each returns a deterministic result server-side; client strictly displays.

First-class modules: slot, plinko, wheel.

All RNG is server-side with a seed and audit log.

6) Economy Mechanics
Daily mint (00:00 UTC)

Sum all users’ unminted_hash_balance.

Compute vault_tax = total * 0.20.

mint_to_users = total - vault_tax.

On-chain:

Mint total HASH to minter address (or mint to Vault and fan-out; choose one pattern and stick to it).

Transfer vault_tax to VAULT_ADDRESS.

Transfer each user’s share to their internal ledger, then settle to on-chain batched if you prefer. For simplicity v1: keep on-chain in Vault and reflect user balances in DB; allow withdrawals any time. If you insist on minting directly to users, batch transfers.

DB:

Set each user’s hash_balance += user_unminted * 0.8.

Set Vault hash_balance += vault_tax.

Zero all unminted_hash_balance.

Record a “MintRun” audit row (create a table if you want full history).

Trade-in (Unminted → HASH at 50%)

Endpoint: POST /economy/trade-in with amount.

Validate amount <= user.unminted_hash_balance.

DB:

user.unminted_hash_balance -= amount

user.hash_balance += amount * 0.5

vault.unminted_hash_balance += amount

vault.hash_balance -= amount * 0.5

Emit updates via Socket.IO.

Withdrawals

Endpoint: POST /wallet/withdraw with amount.

Backend signs and sends HASH.transfer(user.wallet, amount) from Vault hot wallet.

Record tx hash; optimistic UI can show “pending.”

Anti-abuse: cool-down per withdraw, and minimum withdraw.

7) NFT Mechanics

Contract: ERC-721 (if unique art) or ERC-1155 (if classes). Start with 721 unless you expect high supply per type.

Metadata: may be on-chain minimal JSON or IPFS. v1: store requirement fields in contract or an on-chain mapping; mirror to DB for faster checks.

Fields per NFT type

level

burn_requirement_amount

burn_requirement_frequency (daily/weekly)

reward_value

merge_class (only merge same class)

grace_hours (optional for late burns)

Lifecycle

active: user must meet burns within each window.

destroyed: requirement missed; contract sends escrowed reward back to Vault admin. Burn or mark invalid.

completed: requirement satisfied for full schedule; call releaseReward to pay owner.

mergeable: two or more completed NFTs of same class can be merged to mint next-level NFT.

Endpoints

GET /nfts list user NFTs with status/progress.

POST /nfts/:id/burn burns burn_requirement_amount from user hash_balance, updates progress.

POST /nfts/merge with array of token_ids, returns new token_id on success.

Cron validator runs hourly:

For active NFTs, if window expired and requirement not met, mark destroyed and emit event.

8) Contracts Interface (minimum)

Actual ABI will live in hashtoken-deploy. Agents must not rename functions arbitrarily.

HASH (ERC-20)

function mint(address to, uint256 amount) external;        // if using a minter role
function transfer(address to, uint256 amount) external returns (bool);
function balanceOf(address) external view returns (uint256);


NFT (ERC-721)

function mintTo(address to, bytes memory typeData) external returns (uint256);
function markCompleted(uint256 tokenId) external;          // or compute via state machine
function destroy(uint256 tokenId) external;                // revoke, send reward back to vault
function releaseReward(uint256 tokenId) external;          // transfers escrowed reward to owner
function merge(uint256[] calldata tokenIds) external returns (uint256 newTokenId);


If escrowed rewards are truly on-chain, NFT contract must hold/release funds. Simpler v1: store reward_value off-chain and pay from Vault on completion; log on-chain state for transparency.

9) API Surface (Backend)

Base URL: https://api.hashequity.com

POST /auth/nonce → { nonce }

POST /auth/verify { address, signature } → session token

GET /game/objects → array of 10 objects

POST /game/objects/:id/destroy → { reward, newObject }

GET /balances → { hash, unminted }

POST /economy/trade-in { amount } → updated balances

POST /wallet/withdraw { amount } → { txHash }

GET /nfts → user NFTs with status

POST /nfts/:id/burn → updated NFT progress + balances

POST /nfts/merge { tokenIds: string[] } → { newTokenId }

Admin (protect with role or secret):

GET /admin/overview → { totals, vault, activeUsers, dailyEvents }

GET /admin/spawn-table / POST /admin/spawn-table

GET /admin/mint-history

Sockets

Namespace: /realtime

Events:

balances:update { hash, unminted }

objects:replace { newObject }

nfts:update { tokenId, status, progress }

admin:metrics { ... }

10) Schedules & Cron

00:00 UTC daily: mintRun()

Steps: lock, compute totals, call contracts, patch DB, unlock, emit metrics.

hourly: validateNftWindows()

Destroy overdue, mark completed windows, send events.

5 min: telemetryFlush()

Aggregate counters: DAU, clicks, spawn distribution, object payouts.

Locking: use advisory locks in Postgres or a simple “cron in single instance” if only one backend instance runs.

11) Admin Dashboard

Cards: Vault HASH, Vault Unminted, Circulating Supply, 24h Minted, 24h Tax.

Charts: object destroy counts by type, unminted accrual/second, active users per minute.

Tables: top players, failing NFTs soon, recent withdrawals, cron health.

12) Security & Abuse

Rate-limit object destroy endpoint by wallet and IP.

Server owns RNG for mini-games; never trust client outcomes.

Withdrawal cool-down + min amount; blacklist addresses on abuse.

Hot wallet:

Keep in dedicated machine account; rotate key if leaked; consider multisig later.

13) Testing & Quality Gates

Unit:

Economy math (mint, tax, trade-in), RNG determinism, spawn selection.

Integration:

Destroy → event → balance change.

Cron mint end-to-end with mock RPC.

NFT burn windows.

E2E:

Wallet connect, click loop, live balances.

Trade-in and withdrawal flow.

CI must fail if:

Prisma schema changed without migration.

Endpoints or socket events changed without updating this file and openapi.yaml.

14) Observability

Request logs with requestId.

Metrics counters: clicks_total, unminted_total, minted_total, withdrawals_total.

Cron logs with durations and success/failure flags.

Error alerting to on-call channel.

15) AI Agent Rules of Engagement

Do

Follow this spec. If something’s missing, propose a diff in a PR that includes updates to AGENTS.md.

Use small, composable PRs with passing tests.

Keep deterministic seeds in tests.

Don’t

Redesign schemas or rename endpoints without updating this file.

Add client-side RNG that affects payouts.

Touch environment variables in code; read from config only.

Branch & PR

Branch: feat/<scope>, fix/<scope>, ops/<scope>.

PR template must include:

What changed and why

Any schema or API changes

How to test locally

Screenshots for UI

16) Developer Setup (Local)

Backend:

cp .env.example .env
# fill DATABASE_URL, RPC_URL, etc.
pnpm i
pnpm prisma migrate dev
pnpm dev


Frontend:

cp .env.example .env
pnpm i
pnpm dev


Contracts:

cp .env.example .env
# set RPC + PRIVATE_KEY
pnpm i
pnpm test
pnpm deploy:polygon

17) Spawn Table Example (server-side JSON)
[
  { "type": "circle", "spawnChance": 0.65, "reward": { "type": "unminted_hash", "value": "0.0000000100" } },
  { "type": "wheel",  "spawnChance": 0.15, "reward": { "type": "mini_game" } },
  { "type": "slot",   "spawnChance": 0.12, "reward": { "type": "mini_game" } },
  { "type": "plinko", "spawnChance": 0.08, "reward": { "type": "mini_game" } }
]


Sum must equal 1.0. Modify through admin endpoint only.

18) Open Questions (track as issues, not guesses)

Do we mint to Vault and track user balances off-chain with on-demand withdrawals, or do we fan-out on-chain at mint run? v1 recommendation: mint to Vault, ledger in DB, withdraw on demand.

NFT rewards on-chain escrow vs off-chain payout: start off-chain via Vault, add escrow later.

19) Changelog Discipline

Every structural change must update this file in the same PR.

If a service contradicts AGENTS.md, reject the PR or bring the spec up to date first.

Appendix A: Minimal OpenAPI Sketch

Not full OpenAPI, but enough to stop endpoint drift:

GET  /game/objects
POST /game/objects/{id}/destroy
GET  /balances
POST /economy/trade-in
POST /wallet/withdraw
GET  /nfts
POST /nfts/{id}/burn
POST /nfts/merge
GET  /admin/overview
GET  /admin/spawn-table

POST /admin/spawn-table
